{"ast":null,"code":"//////////////////////////////////////////\n// Needle -- HTTP Client for Node.js\n// Written by Tomás Pollak <tomas@forkhq.com>\n// (c) 2012-2020 - Fork Ltd.\n// MIT Licensed\n//////////////////////////////////////////\nvar fs = require('fs'),\n    http = require('http'),\n    https = require('https'),\n    url = require('url'),\n    stream = require('stream'),\n    debug = require('debug')('needle'),\n    stringify = require('./querystring').build,\n    multipart = require('./multipart'),\n    auth = require('./auth'),\n    cookies = require('./cookies'),\n    parsers = require('./parsers'),\n    decoder = require('./decoder'); //////////////////////////////////////////\n// variabilia\n\n\nvar version = require('../package.json').version;\n\nvar user_agent = 'Needle/' + version;\nuser_agent += ' (Node.js ' + process.version + '; ' + process.platform + ' ' + process.arch + ')';\nvar tls_options = 'pfx key passphrase cert ca ciphers rejectUnauthorized secureProtocol checkServerIdentity family'; // older versions of node (< 0.11.4) prevent the runtime from exiting\n// because of connections in keep-alive state. so if this is the case\n// we'll default new requests to set a Connection: close header.\n\nvar close_by_default = !http.Agent || http.Agent.defaultMaxSockets != Infinity; // see if we have Object.assign. otherwise fall back to util._extend\n\nvar extend = Object.assign ? Object.assign : require('util')._extend; // these are the status codes that Needle interprets as redirects.\n\nvar redirect_codes = [301, 302, 303, 307, 308]; //////////////////////////////////////////\n// decompressors for gzip/deflate/br bodies\n\nfunction bind_opts(fn, options) {\n  return fn.bind(null, options);\n}\n\nvar decompressors = {};\n\ntry {\n  var zlib = require('zlib'); // Enable Z_SYNC_FLUSH to avoid Z_BUF_ERROR errors (Node PR #2595)\n\n\n  var zlib_options = {\n    flush: zlib.Z_SYNC_FLUSH,\n    finishFlush: zlib.Z_SYNC_FLUSH\n  };\n  var br_options = {\n    flush: zlib.BROTLI_OPERATION_FLUSH,\n    finishFlush: zlib.BROTLI_OPERATION_FLUSH\n  };\n  decompressors['x-deflate'] = bind_opts(zlib.Inflate, zlib_options);\n  decompressors['deflate'] = bind_opts(zlib.Inflate, zlib_options);\n  decompressors['x-gzip'] = bind_opts(zlib.Gunzip, zlib_options);\n  decompressors['gzip'] = bind_opts(zlib.Gunzip, zlib_options);\n\n  if (typeof zlib.BrotliDecompress === 'function') {\n    decompressors['br'] = bind_opts(zlib.BrotliDecompress, br_options);\n  }\n} catch (e) {\n  /* zlib not available */\n} //////////////////////////////////////////\n// options and aliases\n\n\nvar defaults = {\n  // data\n  boundary: '--------------------NODENEEDLEHTTPCLIENT',\n  encoding: 'utf8',\n  parse_response: 'all',\n  // same as true. valid options: 'json', 'xml' or false/null\n  proxy: null,\n  // agent & headers\n  agent: null,\n  headers: {},\n  accept: '*/*',\n  user_agent: user_agent,\n  // numbers\n  open_timeout: 10000,\n  response_timeout: 0,\n  read_timeout: 0,\n  follow_max: 0,\n  stream_length: -1,\n  // booleans\n  compressed: false,\n  decode_response: true,\n  parse_cookies: true,\n  follow_set_cookies: false,\n  follow_set_referer: false,\n  follow_keep_method: false,\n  follow_if_same_host: false,\n  follow_if_same_protocol: false,\n  follow_if_same_location: false\n};\nvar aliased = {\n  options: {\n    decode: 'decode_response',\n    parse: 'parse_response',\n    timeout: 'open_timeout',\n    follow: 'follow_max'\n  },\n  inverted: {}\n}; // only once, invert aliased keys so we can get passed options.\n\nObject.keys(aliased.options).map(function (k) {\n  var value = aliased.options[k];\n  aliased.inverted[value] = k;\n}); //////////////////////////////////////////\n// helpers\n\nfunction get_env_var(keys, try_lower) {\n  var val,\n      i = -1,\n      env = process.env;\n\n  while (!val && i < keys.length - 1) {\n    val = env[keys[++i]];\n\n    if (!val && try_lower) {\n      val = env[keys[i].toLowerCase()];\n    }\n  }\n\n  return val;\n}\n\nfunction keys_by_type(type) {\n  return Object.keys(defaults).map(function (el) {\n    if (defaults[el] !== null && defaults[el].constructor == type) return el;\n  }).filter(function (el) {\n    return el;\n  });\n}\n\nfunction parse_content_type(header) {\n  if (!header || header === '') return {};\n  var found,\n      charset = 'utf8',\n      arr = header.split(';');\n  if (arr.length > 1 && (found = arr[1].match(/charset=(.+)/))) charset = found[1];\n  return {\n    type: arr[0],\n    charset: charset\n  };\n}\n\nfunction is_stream(obj) {\n  return typeof obj.pipe === 'function';\n}\n\nfunction get_stream_length(stream, given_length, cb) {\n  if (given_length > 0) return cb(given_length);\n  if (stream.end !== void 0 && stream.end !== Infinity && stream.start !== void 0) return cb(stream.end + 1 - (stream.start || 0));\n  fs.stat(stream.path, function (err, stat) {\n    cb(stat ? stat.size - (stream.start || 0) : null);\n  });\n}\n\nfunction resolve_url(href, base) {\n  if (url.URL) return new url.URL(href, base); // older Node version (< v6.13)\n\n  return base ? url.resolve(base, href) : href;\n}\n\nfunction host_and_ports_match(url1, url2) {\n  if (url1.indexOf('http') < 0) url1 = 'http://' + url1;\n  if (url2.indexOf('http') < 0) url2 = 'http://' + url2;\n  var a = url.parse(url1),\n      b = url.parse(url2);\n  return a.host == b.host && String(a.port || (a.protocol == 'https:' ? 443 : 80)) == String(b.port || (b.protocol == 'https:' ? 443 : 80));\n} // returns false if a no_proxy host matches given url\n\n\nfunction should_proxy_to(url) {\n  var no_proxy = get_env_var(['NO_PROXY'], true);\n  if (!no_proxy) return true;\n  var host,\n      hosts = no_proxy.split(',');\n\n  for (var i in hosts) {\n    host = hosts[i];\n\n    if (host_and_ports_match(host, url)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction pump_streams(streams, cb) {\n  if (stream.pipeline) return stream.pipeline.apply(null, streams.concat(cb));\n  var tmp = streams.shift();\n\n  while (streams.length) {\n    tmp = tmp.pipe(streams.shift());\n    tmp.once('error', function (e) {\n      cb && cb(e);\n      cb = null;\n    });\n  }\n} //////////////////////////////////////////\n// the main act\n\n\nfunction Needle(method, uri, data, options, callback) {\n  // if (!(this instanceof Needle)) {\n  //   return new Needle(method, uri, data, options, callback);\n  // }\n  if (typeof uri !== 'string') throw new TypeError('URL must be a string, not ' + uri);\n  this.method = method.toLowerCase();\n  this.uri = uri;\n  this.data = data;\n\n  if (typeof options == 'function') {\n    this.callback = options;\n    this.options = {};\n  } else {\n    this.callback = callback;\n    this.options = options;\n  }\n}\n\nNeedle.prototype.setup = function (uri, options) {\n  function get_option(key, fallback) {\n    // if original is in options, return that value\n    if (typeof options[key] != 'undefined') return options[key]; // otherwise, return value from alias or fallback/undefined\n\n    return typeof options[aliased.inverted[key]] != 'undefined' ? options[aliased.inverted[key]] : fallback;\n  }\n\n  function check_value(expected, key) {\n    var value = get_option(key),\n        type = typeof value;\n    if (type != 'undefined' && type != expected) throw new TypeError(type + ' received for ' + key + ', but expected a ' + expected);\n    return type == expected ? value : defaults[key];\n  } //////////////////////////////////////////////////\n  // the basics\n\n\n  var config = {\n    http_opts: {\n      agent: get_option('agent', defaults.agent),\n      localAddress: get_option('localAddress', undefined),\n      lookup: get_option('lookup', undefined)\n    },\n    // passed later to http.request() directly\n    headers: {},\n    output: options.output,\n    proxy: get_option('proxy', defaults.proxy),\n    parser: get_option('parse_response', defaults.parse_response),\n    encoding: options.encoding || (options.multipart ? 'binary' : defaults.encoding)\n  };\n  keys_by_type(Boolean).forEach(function (key) {\n    config[key] = check_value('boolean', key);\n  });\n  keys_by_type(Number).forEach(function (key) {\n    config[key] = check_value('number', key);\n  }); // populate http_opts with given TLS options\n\n  tls_options.split(' ').forEach(function (key) {\n    if (typeof options[key] != 'undefined') {\n      if (config.http_opts.agent) {\n        // pass option to existing agent\n        config.http_opts.agent.options[key] = options[key];\n      } else {\n        config.http_opts[key] = options[key];\n      }\n    }\n  }); //////////////////////////////////////////////////\n  // headers, cookies\n\n  for (var key in defaults.headers) config.headers[key] = defaults.headers[key];\n\n  config.headers['accept'] = options.accept || defaults.accept;\n  config.headers['user-agent'] = options.user_agent || defaults.user_agent;\n  if (options.content_type) config.headers['content-type'] = options.content_type; // set connection header if opts.connection was passed, or if node < 0.11.4 (close)\n\n  if (options.connection || close_by_default) config.headers['connection'] = options.connection || 'close';\n  if ((options.compressed || defaults.compressed) && typeof zlib != 'undefined') config.headers['accept-encoding'] = decompressors['br'] ? 'gzip, deflate, br' : 'gzip, deflate';\n  if (options.cookies) config.headers['cookie'] = cookies.write(options.cookies); //////////////////////////////////////////////////\n  // basic/digest auth\n\n  if (uri.match(/[^\\/]@/)) {\n    // url contains user:pass@host, so parse it.\n    var parts = (url.parse(uri).auth || '').split(':');\n    options.username = parts[0];\n    options.password = parts[1];\n  }\n\n  if (options.username) {\n    if (options.auth && (options.auth == 'auto' || options.auth == 'digest')) {\n      config.credentials = [options.username, options.password];\n    } else {\n      config.headers['authorization'] = auth.basic(options.username, options.password);\n    }\n  }\n\n  var env_proxy = get_env_var(['HTTP_PROXY', 'HTTPS_PROXY'], true);\n  if (!config.proxy && env_proxy) config.proxy = env_proxy; // if proxy is present, set auth header from either url or proxy_user option.\n\n  if (config.proxy) {\n    if (should_proxy_to(uri)) {\n      if (config.proxy.indexOf('http') === -1) config.proxy = 'http://' + config.proxy;\n\n      if (config.proxy.indexOf('@') !== -1) {\n        var proxy = (url.parse(config.proxy).auth || '').split(':');\n        options.proxy_user = proxy[0];\n        options.proxy_pass = proxy[1];\n      }\n\n      if (options.proxy_user) config.headers['proxy-authorization'] = auth.basic(options.proxy_user, options.proxy_pass);\n    } else {\n      delete config.proxy;\n    }\n  } // now that all our headers are set, overwrite them if instructed.\n\n\n  for (var h in options.headers) config.headers[h.toLowerCase()] = options.headers[h];\n\n  config.uri_modifier = get_option('uri_modifier', null);\n  return config;\n};\n\nNeedle.prototype.start = function () {\n  var out = new stream.PassThrough({\n    objectMode: false\n  }),\n      uri = this.uri,\n      data = this.data,\n      method = this.method,\n      callback = typeof this.options == 'function' ? this.options : this.callback,\n      options = this.options || {}; // if no 'http' is found on URL, prepend it.\n\n  if (uri.indexOf('http') === -1) uri = uri.replace(/^(\\/\\/)?/, 'http://');\n  var self = this,\n      body,\n      waiting = false,\n      config = this.setup(uri, options); // unless options.json was set to false, assume boss also wants JSON if content-type matches.\n\n  var json = options.json || options.json !== false && config.headers['content-type'] == 'application/json';\n\n  if (data) {\n    if (options.multipart) {\n      // boss says we do multipart. so we do it.\n      var boundary = options.boundary || defaults.boundary;\n      waiting = true;\n      multipart.build(data, boundary, function (err, parts) {\n        if (err) throw err;\n        config.headers['content-type'] = 'multipart/form-data; boundary=' + boundary;\n        next(parts);\n      });\n    } else if (is_stream(data)) {\n      if (method == 'get') throw new Error('Refusing to pipe() a stream via GET. Did you mean .post?');\n\n      if (config.stream_length > 0 || config.stream_length === 0 && data.path) {\n        // ok, let's get the stream's length and set it as the content-length header.\n        // this prevents some servers from cutting us off before all the data is sent.\n        waiting = true;\n        get_stream_length(data, config.stream_length, function (length) {\n          data.length = length;\n          next(data);\n        });\n      } else {\n        // if the boss doesn't want us to get the stream's length, or if it doesn't\n        // have a file descriptor for that purpose, then just head on.\n        body = data;\n      }\n    } else if (Buffer.isBuffer(data)) {\n      body = data; // use the raw buffer as request body.\n    } else if (method == 'get' && !json) {\n      // append the data to the URI as a querystring.\n      uri = uri.replace(/\\?.*|$/, '?' + stringify(data));\n    } else {\n      // string or object data, no multipart.\n      // if string, leave it as it is, otherwise, stringify.\n      body = typeof data === 'string' ? data : json ? JSON.stringify(data) : stringify(data); // ensure we have a buffer so bytecount is correct.\n\n      body = Buffer.from(body, config.encoding);\n    }\n  }\n\n  function next(body) {\n    if (body) {\n      if (body.length) config.headers['content-length'] = body.length; // if no content-type was passed, determine if json or not.\n\n      if (!config.headers['content-type']) {\n        config.headers['content-type'] = json ? 'application/json; charset=utf-8' : 'application/x-www-form-urlencoded'; // no charset says W3 spec.\n      }\n    } // unless a specific accept header was set, assume json: true wants JSON back.\n\n\n    if (options.json && !options.accept && !(options.headers || {}).accept) config.headers['accept'] = 'application/json';\n    self.send_request(1, method, uri, config, body, out, callback);\n  }\n\n  if (!waiting) next(body);\n  return out;\n};\n\nNeedle.prototype.get_request_opts = function (method, uri, config) {\n  var opts = config.http_opts,\n      proxy = config.proxy,\n      remote = proxy ? url.parse(proxy) : url.parse(uri);\n  opts.protocol = remote.protocol;\n  opts.host = remote.hostname;\n  opts.port = remote.port || (remote.protocol == 'https:' ? 443 : 80);\n  opts.path = proxy ? uri : remote.pathname + (remote.search || '');\n  opts.method = method;\n  opts.headers = config.headers;\n\n  if (!opts.headers['host']) {\n    // if using proxy, make sure the host header shows the final destination\n    var target = proxy ? url.parse(uri) : remote;\n    opts.headers['host'] = target.hostname; // and if a non standard port was passed, append it to the port header\n\n    if (target.port && [80, 443].indexOf(target.port) === -1) {\n      opts.headers['host'] += ':' + target.port;\n    }\n  }\n\n  return opts;\n};\n\nNeedle.prototype.should_follow = function (location, config, original) {\n  if (!location) return false; // returns true if location contains matching property (host or protocol)\n\n  function matches(property) {\n    var property = original[property];\n    return location.indexOf(property) !== -1;\n  } // first, check whether the requested location is actually different from the original\n\n\n  if (!config.follow_if_same_location && location === original) return false;\n  if (config.follow_if_same_host && !matches('host')) return false; // host does not match, so not following\n\n  if (config.follow_if_same_protocol && !matches('protocol')) return false; // procotol does not match, so not following\n\n  return true;\n};\n\nNeedle.prototype.send_request = function (count, method, uri, config, post_data, out, callback) {\n  if (typeof config.uri_modifier === 'function') {\n    var modified_uri = config.uri_modifier(uri);\n    debug('Modifying request URI', uri + ' => ' + modified_uri);\n    uri = modified_uri;\n  }\n\n  var request,\n      timer,\n      returned = 0,\n      self = this,\n      request_opts = this.get_request_opts(method, uri, config),\n      protocol = request_opts.protocol == 'https:' ? https : http;\n\n  function done(err, resp) {\n    if (returned++ > 0) return debug('Already finished, stopping here.');\n    if (timer) clearTimeout(timer);\n    request.removeListener('error', had_error);\n    out.done = true; // An error can still be fired after closing.  In particular, on macOS.\n    // See also:\n    //  - https://github.com/tomas/needle/issues/391\n    //  - https://github.com/less/less.js/issues/3693\n    //  - https://github.com/nodejs/node/issues/27916\n\n    request.once('error', function () {});\n    if (callback) return callback(err, resp, resp ? resp.body : undefined); // NOTE: this event used to be called 'end', but the behaviour was confusing\n    // when errors ocurred, because the stream would still emit an 'end' event.\n\n    out.emit('done', err); // trigger the 'done' event on streams we're being piped to, if any\n\n    var pipes = out._readableState.pipes || [];\n    if (!pipes.forEach) pipes = [pipes];\n    pipes.forEach(function (st) {\n      st.emit('done', err);\n    });\n  }\n\n  function had_error(err) {\n    debug('Request error', err);\n    out.emit('err', err);\n    done(err || new Error('Unknown error when making request.'));\n  }\n\n  function set_timeout(type, milisecs) {\n    if (timer) clearTimeout(timer);\n    if (milisecs <= 0) return;\n    timer = setTimeout(function () {\n      out.emit('timeout', type);\n      request.abort(); // also invoke done() to terminate job on read_timeout\n\n      if (type == 'read') done(new Error(type + ' timeout'));\n    }, milisecs);\n  } // handle errors on the underlying socket, that may be closed while writing\n  // for an example case, see test/long_string_spec.js. we make sure this\n  // scenario ocurred by verifying the socket's writable & destroyed states.\n\n\n  function on_socket_end() {\n    if (returned && !this.writable && this.destroyed === false) {\n      this.destroy();\n      had_error(new Error('Remote end closed socket abruptly.'));\n    }\n  }\n\n  debug('Making request #' + count, request_opts);\n  request = protocol.request(request_opts, function (resp) {\n    var headers = resp.headers;\n    debug('Got response', resp.statusCode, headers);\n    out.emit('response', resp);\n    set_timeout('read', config.read_timeout); // if we got cookies, parse them unless we were instructed not to. make sure to include any\n    // cookies that might have been set on previous redirects.\n\n    if (config.parse_cookies && (headers['set-cookie'] || config.previous_resp_cookies)) {\n      resp.cookies = extend(config.previous_resp_cookies || {}, cookies.read(headers['set-cookie']));\n      debug('Got cookies', resp.cookies);\n    } // if redirect code is found, determine if we should follow it according to the given options.\n\n\n    if (redirect_codes.indexOf(resp.statusCode) !== -1 && self.should_follow(headers.location, config, uri)) {\n      // clear timer before following redirects to prevent unexpected setTimeout consequence\n      clearTimeout(timer);\n\n      if (count <= config.follow_max) {\n        out.emit('redirect', headers.location); // unless 'follow_keep_method' is true, rewrite the request to GET before continuing.\n\n        if (!config.follow_keep_method) {\n          method = 'GET';\n          post_data = null;\n          delete config.headers['content-length']; // in case the original was a multipart POST request.\n        } // if follow_set_cookies is true, insert cookies in the next request's headers.\n        // we set both the original request cookies plus any response cookies we might have received.\n\n\n        if (config.follow_set_cookies && host_and_ports_match(headers.location, uri)) {\n          var request_cookies = cookies.read(config.headers['cookie']);\n          config.previous_resp_cookies = resp.cookies;\n\n          if (Object.keys(request_cookies).length || Object.keys(resp.cookies || {}).length) {\n            config.headers['cookie'] = cookies.write(extend(request_cookies, resp.cookies));\n          }\n        } else if (config.headers['cookie']) {\n          debug('Clearing original request cookie', config.headers['cookie']);\n          delete config.headers['cookie'];\n        }\n\n        if (config.follow_set_referer) config.headers['referer'] = encodeURI(uri); // the original, not the destination URL.\n\n        config.headers['host'] = null; // clear previous Host header to avoid conflicts.\n\n        var redirect_url = resolve_url(headers.location, uri);\n        debug('Redirecting to ' + redirect_url.toString());\n        return self.send_request(++count, method, redirect_url.toString(), config, post_data, out, callback);\n      } else if (config.follow_max > 0) {\n        return done(new Error('Max redirects reached. Possible loop in: ' + headers.location));\n      }\n    } // if auth is requested and credentials were not passed, resend request, provided we have user/pass.\n\n\n    if (resp.statusCode == 401 && headers['www-authenticate'] && config.credentials) {\n      if (!config.headers['authorization']) {\n        // only if authentication hasn't been sent\n        var auth_header = auth.header(headers['www-authenticate'], config.credentials, request_opts);\n\n        if (auth_header) {\n          config.headers['authorization'] = auth_header;\n          return self.send_request(count, method, uri, config, post_data, out, callback);\n        }\n      }\n    } // ok, so we got a valid (non-redirect & authorized) response. let's notify the stream guys.\n\n\n    out.emit('header', resp.statusCode, headers);\n    out.emit('headers', headers);\n    var pipeline = [],\n        mime = parse_content_type(headers['content-type']),\n        text_response = mime.type && (mime.type.indexOf('text/') != -1 || !!mime.type.match(/(\\/|\\+)(xml|json)$/)); // To start, if our body is compressed and we're able to inflate it, do it.\n\n    if (headers['content-encoding'] && decompressors[headers['content-encoding']]) {\n      var decompressor = decompressors[headers['content-encoding']](); // make sure we catch errors triggered by the decompressor.\n\n      decompressor.on('error', had_error);\n      pipeline.push(decompressor);\n    } // If parse is enabled and we have a parser for it, then go for it.\n\n\n    if (config.parser && parsers[mime.type]) {\n      // If a specific parser was requested, make sure we don't parse other types.\n      var parser_name = config.parser.toString().toLowerCase();\n\n      if (['xml', 'json'].indexOf(parser_name) == -1 || parsers[mime.type].name == parser_name) {\n        // OK, so either we're parsing all content types or the one requested matches.\n        out.parser = parsers[mime.type].name;\n        pipeline.push(parsers[mime.type].fn()); // Set objectMode on out stream to improve performance.\n\n        out._writableState.objectMode = true;\n        out._readableState.objectMode = true;\n      } // If we're not parsing, and unless decoding was disabled, we'll try\n      // decoding non UTF-8 bodies to UTF-8, using the iconv-lite library.\n\n    } else if (text_response && config.decode_response && mime.charset) {\n      pipeline.push(decoder(mime.charset));\n    } // And `out` is the stream we finally push the decoded/parsed output to.\n\n\n    pipeline.push(out); // Now, release the kraken!\n\n    pump_streams([resp].concat(pipeline), function (err) {\n      if (err) debug(err); // on node v8.x, if an error ocurrs on the receiving end,\n      // then we want to abort the request to avoid having dangling sockets\n\n      if (err && err.message == 'write after end') request.destroy();\n    }); // If the user has requested and output file, pipe the output stream to it.\n    // In stream mode, we will still get the response stream to play with.\n\n    if (config.output && resp.statusCode == 200) {\n      // for some reason, simply piping resp to the writable stream doesn't\n      // work all the time (stream gets cut in the middle with no warning).\n      // so we'll manually need to do the readable/write(chunk) trick.\n      var file = fs.createWriteStream(config.output);\n      file.on('error', had_error);\n      out.on('end', function () {\n        if (file.writable) file.end();\n      });\n      file.on('close', function () {\n        delete out.file;\n      });\n      out.on('readable', function () {\n        var chunk;\n\n        while ((chunk = this.read()) !== null) {\n          if (file.writable) file.write(chunk); // if callback was requested, also push it to resp.body\n\n          if (resp.body) resp.body.push(chunk);\n        }\n      });\n      out.file = file;\n    } // Only aggregate the full body if a callback was requested.\n\n\n    if (callback) {\n      resp.raw = [];\n      resp.body = [];\n      resp.bytes = 0; // Gather and count the amount of (raw) bytes using a PassThrough stream.\n\n      var clean_pipe = new stream.PassThrough();\n      clean_pipe.on('readable', function () {\n        var chunk;\n\n        while ((chunk = this.read()) != null) {\n          resp.bytes += chunk.length;\n          resp.raw.push(chunk);\n        }\n      });\n      pump_streams([resp, clean_pipe], function (err) {\n        if (err) debug(err);\n      }); // Listen on the 'readable' event to aggregate the chunks, but only if\n      // file output wasn't requested. Otherwise we'd have two stream readers.\n\n      if (!config.output || resp.statusCode != 200) {\n        out.on('readable', function () {\n          var chunk;\n\n          while ((chunk = this.read()) !== null) {\n            // We're either pushing buffers or objects, never strings.\n            if (typeof chunk == 'string') chunk = Buffer.from(chunk); // Push all chunks to resp.body. We'll bind them in resp.end().\n\n            resp.body.push(chunk);\n          }\n        });\n      }\n    } // And set the .body property once all data is in.\n\n\n    out.on('end', function () {\n      if (resp.body) {\n        // callback mode\n        // we want to be able to access to the raw data later, so keep a reference.\n        resp.raw = Buffer.concat(resp.raw); // if parse was successful, we should have an array with one object\n\n        if (resp.body[0] !== undefined && !Buffer.isBuffer(resp.body[0])) {\n          // that's our body right there.\n          resp.body = resp.body[0]; // set the parser property on our response. we may want to check.\n\n          if (out.parser) resp.parser = out.parser;\n        } else {\n          // we got one or several buffers. string or binary.\n          resp.body = Buffer.concat(resp.body); // if we're here and parsed is true, it means we tried to but it didn't work.\n          // so given that we got a text response, let's stringify it.\n\n          if (text_response || out.parser) {\n            resp.body = resp.body.toString();\n          }\n        }\n      } // if an output file is being written to, make sure the callback\n      // is triggered after all data has been written to it.\n\n\n      if (out.file) {\n        out.file.on('close', function () {\n          done(null, resp);\n        });\n      } else {\n        // elvis has left the building.\n        done(null, resp);\n      }\n    }); // out.on('error', function(err) {\n    //   had_error(err);\n    //   if (err.code == 'ERR_STREAM_DESTROYED' || err.code == 'ERR_STREAM_PREMATURE_CLOSE') {\n    //     request.abort();\n    //   }\n    // })\n  }); // end request call\n  // unless open_timeout was disabled, set a timeout to abort the request.\n\n  set_timeout('open', config.open_timeout); // handle errors on the request object. things might get bumpy.\n\n  request.on('error', had_error); // make sure timer is cleared if request is aborted (issue #257)\n\n  request.once('abort', function () {\n    if (timer) clearTimeout(timer);\n  }); // handle socket 'end' event to ensure we don't get delayed EPIPE errors.\n\n  request.once('socket', function (socket) {\n    if (socket.connecting) {\n      socket.once('connect', function () {\n        set_timeout('response', config.response_timeout);\n      });\n    } else {\n      set_timeout('response', config.response_timeout);\n    } // socket.once('close', function(e) {\n    //   console.log('socket closed!', e);\n    // })\n\n\n    if (!socket.on_socket_end) {\n      socket.on_socket_end = on_socket_end;\n      socket.once('end', function () {\n        process.nextTick(on_socket_end.bind(socket));\n      });\n    }\n  });\n\n  if (post_data) {\n    if (is_stream(post_data)) {\n      pump_streams([post_data, request], function (err) {\n        if (err) debug(err);\n      });\n    } else {\n      request.write(post_data, config.encoding);\n      request.end();\n    }\n  } else {\n    request.end();\n  }\n\n  out.abort = function () {\n    request.abort();\n  }; // easier access\n\n\n  out.request = request;\n  return out;\n}; //////////////////////////////////////////\n// exports\n\n\nif (typeof Promise !== 'undefined') {\n  module.exports = function () {\n    var verb,\n        args = [].slice.call(arguments);\n    if (args[0].match(/\\.|\\//)) // first argument looks like a URL\n      verb = args.length > 2 ? 'post' : 'get';else verb = args.shift();\n    if (verb.match(/get|head/i) && args.length == 2) args.splice(1, 0, null); // assume no data if head/get with two args (url, options)\n\n    return new Promise(function (resolve, reject) {\n      module.exports.request(verb, args[0], args[1], args[2], function (err, resp) {\n        return err ? reject(err) : resolve(resp);\n      });\n    });\n  };\n}\n\nmodule.exports.version = version;\n\nmodule.exports.defaults = function (obj) {\n  for (var key in obj) {\n    var target_key = aliased.options[key] || key;\n\n    if (defaults.hasOwnProperty(target_key) && typeof obj[key] != 'undefined') {\n      if (target_key != 'parse_response' && target_key != 'proxy' && target_key != 'agent') {\n        // ensure type matches the original, except for proxy/parse_response that can be null/bool or string\n        var valid_type = defaults[target_key].constructor.name;\n        if (obj[key].constructor.name != valid_type) throw new TypeError('Invalid type for ' + key + ', should be ' + valid_type);\n      }\n\n      defaults[target_key] = obj[key];\n    } else {\n      throw new Error('Invalid property for defaults:' + target_key);\n    }\n  }\n\n  return defaults;\n};\n\n'head get'.split(' ').forEach(function (method) {\n  module.exports[method] = function (uri, options, callback) {\n    return new Needle(method, uri, null, options, callback).start();\n  };\n});\n'post put patch delete'.split(' ').forEach(function (method) {\n  module.exports[method] = function (uri, data, options, callback) {\n    return new Needle(method, uri, data, options, callback).start();\n  };\n});\n\nmodule.exports.request = function (method, uri, data, opts, callback) {\n  return new Needle(method, uri, data, opts, callback).start();\n};","map":{"version":3,"names":["fs","require","http","https","url","stream","debug","stringify","build","multipart","auth","cookies","parsers","decoder","version","user_agent","process","platform","arch","tls_options","close_by_default","Agent","defaultMaxSockets","Infinity","extend","Object","assign","_extend","redirect_codes","bind_opts","fn","options","bind","decompressors","zlib","zlib_options","flush","Z_SYNC_FLUSH","finishFlush","br_options","BROTLI_OPERATION_FLUSH","Inflate","Gunzip","BrotliDecompress","e","defaults","boundary","encoding","parse_response","proxy","agent","headers","accept","open_timeout","response_timeout","read_timeout","follow_max","stream_length","compressed","decode_response","parse_cookies","follow_set_cookies","follow_set_referer","follow_keep_method","follow_if_same_host","follow_if_same_protocol","follow_if_same_location","aliased","decode","parse","timeout","follow","inverted","keys","map","k","value","get_env_var","try_lower","val","i","env","length","toLowerCase","keys_by_type","type","el","constructor","filter","parse_content_type","header","found","charset","arr","split","match","is_stream","obj","pipe","get_stream_length","given_length","cb","end","start","stat","path","err","size","resolve_url","href","base","URL","resolve","host_and_ports_match","url1","url2","indexOf","a","b","host","String","port","protocol","should_proxy_to","no_proxy","hosts","pump_streams","streams","pipeline","apply","concat","tmp","shift","once","Needle","method","uri","data","callback","TypeError","prototype","setup","get_option","key","fallback","check_value","expected","config","http_opts","localAddress","undefined","lookup","output","parser","Boolean","forEach","Number","content_type","connection","write","parts","username","password","credentials","basic","env_proxy","proxy_user","proxy_pass","h","uri_modifier","out","PassThrough","objectMode","replace","self","body","waiting","json","next","Error","Buffer","isBuffer","JSON","from","send_request","get_request_opts","opts","remote","hostname","pathname","search","target","should_follow","location","original","matches","property","count","post_data","modified_uri","request","timer","returned","request_opts","done","resp","clearTimeout","removeListener","had_error","emit","pipes","_readableState","st","set_timeout","milisecs","setTimeout","abort","on_socket_end","writable","destroyed","destroy","statusCode","previous_resp_cookies","read","request_cookies","encodeURI","redirect_url","toString","auth_header","mime","text_response","decompressor","on","push","parser_name","name","_writableState","message","file","createWriteStream","chunk","raw","bytes","clean_pipe","socket","connecting","nextTick","Promise","module","exports","verb","args","slice","call","arguments","splice","reject","target_key","hasOwnProperty","valid_type"],"sources":["/mnt/c/users/46721/documents/iths/ITHS-Dashboard/node_modules/needle/lib/needle.js"],"sourcesContent":["//////////////////////////////////////////\n// Needle -- HTTP Client for Node.js\n// Written by Tomás Pollak <tomas@forkhq.com>\n// (c) 2012-2020 - Fork Ltd.\n// MIT Licensed\n//////////////////////////////////////////\n\nvar fs          = require('fs'),\n    http        = require('http'),\n    https       = require('https'),\n    url         = require('url'),\n    stream      = require('stream'),\n    debug       = require('debug')('needle'),\n    stringify   = require('./querystring').build,\n    multipart   = require('./multipart'),\n    auth        = require('./auth'),\n    cookies     = require('./cookies'),\n    parsers     = require('./parsers'),\n    decoder     = require('./decoder');\n\n//////////////////////////////////////////\n// variabilia\n\nvar version     = require('../package.json').version;\n\nvar user_agent  = 'Needle/' + version;\nuser_agent     += ' (Node.js ' + process.version + '; ' + process.platform + ' ' + process.arch + ')';\n\nvar tls_options = 'pfx key passphrase cert ca ciphers rejectUnauthorized secureProtocol checkServerIdentity family';\n\n// older versions of node (< 0.11.4) prevent the runtime from exiting\n// because of connections in keep-alive state. so if this is the case\n// we'll default new requests to set a Connection: close header.\nvar close_by_default = !http.Agent || http.Agent.defaultMaxSockets != Infinity;\n\n// see if we have Object.assign. otherwise fall back to util._extend\nvar extend = Object.assign ? Object.assign : require('util')._extend;\n\n// these are the status codes that Needle interprets as redirects.\nvar redirect_codes = [301, 302, 303, 307, 308];\n\n//////////////////////////////////////////\n// decompressors for gzip/deflate/br bodies\n\nfunction bind_opts(fn, options) {\n  return fn.bind(null, options);\n}\n\nvar decompressors = {};\n\ntry {\n\n  var zlib = require('zlib');\n\n  // Enable Z_SYNC_FLUSH to avoid Z_BUF_ERROR errors (Node PR #2595)\n  var zlib_options = {\n    flush: zlib.Z_SYNC_FLUSH,\n    finishFlush: zlib.Z_SYNC_FLUSH\n  };\n\n  var br_options = {\n    flush: zlib.BROTLI_OPERATION_FLUSH,\n    finishFlush: zlib.BROTLI_OPERATION_FLUSH\n  };\n\n  decompressors['x-deflate'] = bind_opts(zlib.Inflate, zlib_options);\n  decompressors['deflate']   = bind_opts(zlib.Inflate, zlib_options);\n  decompressors['x-gzip']    = bind_opts(zlib.Gunzip, zlib_options);\n  decompressors['gzip']      = bind_opts(zlib.Gunzip, zlib_options);\n  if (typeof zlib.BrotliDecompress === 'function') {\n    decompressors['br']      = bind_opts(zlib.BrotliDecompress, br_options);\n  }\n\n} catch(e) { /* zlib not available */ }\n\n//////////////////////////////////////////\n// options and aliases\n\nvar defaults = {\n  // data\n  boundary                : '--------------------NODENEEDLEHTTPCLIENT',\n  encoding                : 'utf8',\n  parse_response          : 'all', // same as true. valid options: 'json', 'xml' or false/null\n  proxy                   : null,\n\n  // agent & headers\n  agent                   : null,\n  headers                 : {},\n  accept                  : '*/*',\n  user_agent              : user_agent,\n\n  // numbers\n  open_timeout            : 10000,\n  response_timeout        : 0,\n  read_timeout            : 0,\n  follow_max              : 0,\n  stream_length           : -1,\n\n  // booleans\n  compressed              : false,\n  decode_response         : true,\n  parse_cookies           : true,\n  follow_set_cookies      : false,\n  follow_set_referer      : false,\n  follow_keep_method      : false,\n  follow_if_same_host     : false,\n  follow_if_same_protocol : false,\n  follow_if_same_location : false\n}\n\nvar aliased = {\n  options: {\n    decode  : 'decode_response',\n    parse   : 'parse_response',\n    timeout : 'open_timeout',\n    follow  : 'follow_max'\n  },\n  inverted: {}\n}\n\n// only once, invert aliased keys so we can get passed options.\nObject.keys(aliased.options).map(function(k) {\n  var value = aliased.options[k];\n  aliased.inverted[value] = k;\n});\n\n//////////////////////////////////////////\n// helpers\n\nfunction get_env_var(keys, try_lower) {\n  var val, i = -1, env = process.env;\n  while (!val && i < keys.length-1) {\n    val = env[keys[++i]];\n    if (!val && try_lower) {\n      val = env[keys[i].toLowerCase()];\n    }\n  }\n  return val;\n}\n\nfunction keys_by_type(type) {\n  return Object.keys(defaults).map(function(el) {\n    if (defaults[el] !== null && defaults[el].constructor == type)\n      return el;\n  }).filter(function(el) { return el })\n}\n\nfunction parse_content_type(header) {\n  if (!header || header === '') return {};\n\n  var found, charset = 'utf8', arr = header.split(';');\n\n  if (arr.length > 1 && (found = arr[1].match(/charset=(.+)/)))\n    charset = found[1];\n\n  return { type: arr[0], charset: charset };\n}\n\nfunction is_stream(obj) {\n  return typeof obj.pipe === 'function';\n}\n\nfunction get_stream_length(stream, given_length, cb) {\n  if (given_length > 0)\n    return cb(given_length);\n\n  if (stream.end !== void 0 && stream.end !== Infinity && stream.start !== void 0)\n    return cb((stream.end + 1) - (stream.start || 0));\n\n  fs.stat(stream.path, function(err, stat) {\n    cb(stat ? stat.size - (stream.start || 0) : null);\n  });\n}\n\nfunction resolve_url(href, base) {\n  if (url.URL)\n    return new url.URL(href, base);\n\n  // older Node version (< v6.13)\n  return base ? url.resolve(base, href) : href;\n}\n\nfunction host_and_ports_match(url1, url2) {\n  if (url1.indexOf('http') < 0) url1 = 'http://' + url1;\n  if (url2.indexOf('http') < 0) url2 = 'http://' + url2;\n  var a = url.parse(url1), b = url.parse(url2);\n\n  return a.host == b.host\n    && String(a.port || (a.protocol == 'https:' ? 443 : 80))\n    == String(b.port || (b.protocol == 'https:' ? 443 : 80));\n}\n\n// returns false if a no_proxy host matches given url\nfunction should_proxy_to(url) {\n  var no_proxy = get_env_var(['NO_PROXY'], true);\n  if (!no_proxy) return true;\n\n  var host, hosts = no_proxy.split(',');\n  for (var i in hosts) {\n    host = hosts[i];\n    if (host_and_ports_match(host, url)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction pump_streams(streams, cb) {\n  if (stream.pipeline)\n    return stream.pipeline.apply(null, streams.concat(cb));\n\n  var tmp = streams.shift();\n  while (streams.length) {\n    tmp = tmp.pipe(streams.shift());\n    tmp.once('error', function(e) {\n      cb && cb(e);\n      cb = null;\n    })\n  }\n}\n\n//////////////////////////////////////////\n// the main act\n\nfunction Needle(method, uri, data, options, callback) {\n  // if (!(this instanceof Needle)) {\n  //   return new Needle(method, uri, data, options, callback);\n  // }\n\n  if (typeof uri !== 'string')\n    throw new TypeError('URL must be a string, not ' + uri);\n\n  this.method   = method.toLowerCase();\n  this.uri      = uri;\n  this.data     = data;\n\n  if (typeof options == 'function') {\n    this.callback = options;\n    this.options  = {};\n  } else {\n    this.callback = callback;\n    this.options  = options;\n  }\n\n}\n\nNeedle.prototype.setup = function(uri, options) {\n\n  function get_option(key, fallback) {\n    // if original is in options, return that value\n    if (typeof options[key] != 'undefined') return options[key];\n\n    // otherwise, return value from alias or fallback/undefined\n    return typeof options[aliased.inverted[key]] != 'undefined'\n                ? options[aliased.inverted[key]] : fallback;\n  }\n\n  function check_value(expected, key) {\n    var value = get_option(key),\n        type  = typeof value;\n\n    if (type != 'undefined' && type != expected)\n      throw new TypeError(type + ' received for ' + key + ', but expected a ' + expected);\n\n    return (type == expected) ? value : defaults[key];\n  }\n\n  //////////////////////////////////////////////////\n  // the basics\n\n  var config = {\n    http_opts : {\n      agent: get_option('agent', defaults.agent),\n      localAddress: get_option('localAddress', undefined),\n      lookup: get_option('lookup', undefined)\n    }, // passed later to http.request() directly\n    headers   : {},\n    output    : options.output,\n    proxy     : get_option('proxy', defaults.proxy),\n    parser    : get_option('parse_response', defaults.parse_response),\n    encoding  : options.encoding || (options.multipart ? 'binary' : defaults.encoding)\n  }\n\n  keys_by_type(Boolean).forEach(function(key) {\n    config[key] = check_value('boolean', key);\n  })\n\n  keys_by_type(Number).forEach(function(key) {\n    config[key] = check_value('number', key);\n  })\n\n  // populate http_opts with given TLS options\n  tls_options.split(' ').forEach(function(key) {\n    if (typeof options[key] != 'undefined') {\n      if (config.http_opts.agent) { // pass option to existing agent\n        config.http_opts.agent.options[key] = options[key];\n      } else {\n        config.http_opts[key] = options[key];\n      }\n    }\n  });\n\n  //////////////////////////////////////////////////\n  // headers, cookies\n\n  for (var key in defaults.headers)\n    config.headers[key] = defaults.headers[key];\n\n  config.headers['accept'] = options.accept || defaults.accept;\n  config.headers['user-agent'] = options.user_agent || defaults.user_agent;\n\n  if (options.content_type)\n    config.headers['content-type'] = options.content_type;\n\n  // set connection header if opts.connection was passed, or if node < 0.11.4 (close)\n  if (options.connection || close_by_default)\n    config.headers['connection'] = options.connection || 'close';\n\n  if ((options.compressed || defaults.compressed) && typeof zlib != 'undefined')\n    config.headers['accept-encoding'] = decompressors['br'] ? 'gzip, deflate, br' : 'gzip, deflate';\n\n  if (options.cookies)\n    config.headers['cookie'] = cookies.write(options.cookies);\n\n  //////////////////////////////////////////////////\n  // basic/digest auth\n\n  if (uri.match(/[^\\/]@/)) { // url contains user:pass@host, so parse it.\n    var parts = (url.parse(uri).auth || '').split(':');\n    options.username = parts[0];\n    options.password = parts[1];\n  }\n\n  if (options.username) {\n    if (options.auth && (options.auth == 'auto' || options.auth == 'digest')) {\n      config.credentials = [options.username, options.password];\n    } else {\n      config.headers['authorization'] = auth.basic(options.username, options.password);\n    }\n  }\n\n  var env_proxy = get_env_var(['HTTP_PROXY', 'HTTPS_PROXY'], true);\n  if (!config.proxy && env_proxy) config.proxy = env_proxy;\n\n  // if proxy is present, set auth header from either url or proxy_user option.\n  if (config.proxy) {\n    if (should_proxy_to(uri)) {\n      if (config.proxy.indexOf('http') === -1)\n        config.proxy = 'http://' + config.proxy;\n\n      if (config.proxy.indexOf('@') !== -1) {\n        var proxy = (url.parse(config.proxy).auth || '').split(':');\n        options.proxy_user = proxy[0];\n        options.proxy_pass = proxy[1];\n      }\n\n      if (options.proxy_user)\n        config.headers['proxy-authorization'] = auth.basic(options.proxy_user, options.proxy_pass);\n    } else {\n      delete config.proxy;\n    }\n  }\n\n  // now that all our headers are set, overwrite them if instructed.\n  for (var h in options.headers)\n    config.headers[h.toLowerCase()] = options.headers[h];\n\n  config.uri_modifier = get_option('uri_modifier', null);\n\n  return config;\n}\n\nNeedle.prototype.start = function() {\n\n  var out      = new stream.PassThrough({ objectMode: false }),\n      uri      = this.uri,\n      data     = this.data,\n      method   = this.method,\n      callback = (typeof this.options == 'function') ? this.options : this.callback,\n      options  = this.options || {};\n\n  // if no 'http' is found on URL, prepend it.\n  if (uri.indexOf('http') === -1)\n    uri = uri.replace(/^(\\/\\/)?/, 'http://');\n\n  var self = this, body, waiting = false, config = this.setup(uri, options);\n\n  // unless options.json was set to false, assume boss also wants JSON if content-type matches.\n  var json = options.json || (options.json !== false && config.headers['content-type'] == 'application/json');\n\n  if (data) {\n\n    if (options.multipart) { // boss says we do multipart. so we do it.\n      var boundary = options.boundary || defaults.boundary;\n\n      waiting = true;\n      multipart.build(data, boundary, function(err, parts) {\n        if (err) throw(err);\n\n        config.headers['content-type'] = 'multipart/form-data; boundary=' + boundary;\n        next(parts);\n      });\n\n    } else if (is_stream(data)) {\n\n      if (method == 'get')\n        throw new Error('Refusing to pipe() a stream via GET. Did you mean .post?');\n\n      if (config.stream_length > 0 || (config.stream_length === 0 && data.path)) {\n        // ok, let's get the stream's length and set it as the content-length header.\n        // this prevents some servers from cutting us off before all the data is sent.\n        waiting = true;\n        get_stream_length(data, config.stream_length, function(length) {\n          data.length = length;\n          next(data);\n        })\n\n      } else {\n        // if the boss doesn't want us to get the stream's length, or if it doesn't\n        // have a file descriptor for that purpose, then just head on.\n        body = data;\n      }\n\n    } else if (Buffer.isBuffer(data)) {\n\n      body = data; // use the raw buffer as request body.\n\n    } else if (method == 'get' && !json) {\n\n      // append the data to the URI as a querystring.\n      uri = uri.replace(/\\?.*|$/, '?' + stringify(data));\n\n    } else { // string or object data, no multipart.\n\n      // if string, leave it as it is, otherwise, stringify.\n      body = (typeof(data) === 'string') ? data\n             : json ? JSON.stringify(data) : stringify(data);\n\n      // ensure we have a buffer so bytecount is correct.\n      body = Buffer.from(body, config.encoding);\n    }\n\n  }\n\n  function next(body) {\n    if (body) {\n      if (body.length) config.headers['content-length'] = body.length;\n\n      // if no content-type was passed, determine if json or not.\n      if (!config.headers['content-type']) {\n        config.headers['content-type'] = json\n        ? 'application/json; charset=utf-8'\n        : 'application/x-www-form-urlencoded'; // no charset says W3 spec.\n      }\n    }\n\n    // unless a specific accept header was set, assume json: true wants JSON back.\n    if (options.json && (!options.accept && !(options.headers || {}).accept))\n      config.headers['accept'] = 'application/json';\n\n    self.send_request(1, method, uri, config, body, out, callback);\n  }\n\n  if (!waiting) next(body);\n  return out;\n}\n\nNeedle.prototype.get_request_opts = function(method, uri, config) {\n  var opts      = config.http_opts,\n      proxy     = config.proxy,\n      remote    = proxy ? url.parse(proxy) : url.parse(uri);\n\n  opts.protocol = remote.protocol;\n  opts.host     = remote.hostname;\n  opts.port     = remote.port || (remote.protocol == 'https:' ? 443 : 80);\n  opts.path     = proxy ? uri : remote.pathname + (remote.search || '');\n  opts.method   = method;\n  opts.headers  = config.headers;\n\n  if (!opts.headers['host']) {\n    // if using proxy, make sure the host header shows the final destination\n    var target = proxy ? url.parse(uri) : remote;\n    opts.headers['host'] = target.hostname;\n\n    // and if a non standard port was passed, append it to the port header\n    if (target.port && [80, 443].indexOf(target.port) === -1) {\n      opts.headers['host'] += ':' + target.port;\n    }\n  }\n\n  return opts;\n}\n\nNeedle.prototype.should_follow = function(location, config, original) {\n  if (!location) return false;\n\n  // returns true if location contains matching property (host or protocol)\n  function matches(property) {\n    var property = original[property];\n    return location.indexOf(property) !== -1;\n  }\n\n  // first, check whether the requested location is actually different from the original\n  if (!config.follow_if_same_location && location === original)\n    return false;\n\n  if (config.follow_if_same_host && !matches('host'))\n    return false; // host does not match, so not following\n\n  if (config.follow_if_same_protocol && !matches('protocol'))\n    return false; // procotol does not match, so not following\n\n  return true;\n}\n\nNeedle.prototype.send_request = function(count, method, uri, config, post_data, out, callback) {\n\n  if (typeof config.uri_modifier === 'function') {\n    var modified_uri = config.uri_modifier(uri);\n    debug('Modifying request URI', uri + ' => ' + modified_uri);\n    uri = modified_uri;\n  }\n\n  var request,\n      timer,\n      returned     = 0,\n      self         = this,\n      request_opts = this.get_request_opts(method, uri, config),\n      protocol     = request_opts.protocol == 'https:' ? https : http;\n\n  function done(err, resp) {\n    if (returned++ > 0)\n      return debug('Already finished, stopping here.');\n\n    if (timer) clearTimeout(timer);\n    request.removeListener('error', had_error);\n    out.done = true;\n\n    // An error can still be fired after closing.  In particular, on macOS.\n    // See also:\n    //  - https://github.com/tomas/needle/issues/391\n    //  - https://github.com/less/less.js/issues/3693\n    //  - https://github.com/nodejs/node/issues/27916\n    request.once('error', function() {});\n\n    if (callback)\n      return callback(err, resp, resp ? resp.body : undefined);\n\n    // NOTE: this event used to be called 'end', but the behaviour was confusing\n    // when errors ocurred, because the stream would still emit an 'end' event.\n    out.emit('done', err);\n\n    // trigger the 'done' event on streams we're being piped to, if any\n    var pipes = out._readableState.pipes || [];\n    if (!pipes.forEach) pipes = [pipes];\n    pipes.forEach(function(st) { st.emit('done', err); })\n  }\n\n  function had_error(err) {\n    debug('Request error', err);\n    out.emit('err', err);\n    done(err || new Error('Unknown error when making request.'));\n  }\n\n  function set_timeout(type, milisecs) {\n    if (timer) clearTimeout(timer);\n    if (milisecs <= 0) return;\n\n    timer = setTimeout(function() {\n      out.emit('timeout', type);\n      request.abort();\n      // also invoke done() to terminate job on read_timeout\n      if (type == 'read') done(new Error(type + ' timeout'));\n    }, milisecs);\n  }\n\n  // handle errors on the underlying socket, that may be closed while writing\n  // for an example case, see test/long_string_spec.js. we make sure this\n  // scenario ocurred by verifying the socket's writable & destroyed states.\n  function on_socket_end() {\n    if (returned && !this.writable && this.destroyed === false) {\n      this.destroy();\n      had_error(new Error('Remote end closed socket abruptly.'))\n    }\n  }\n\n  debug('Making request #' + count, request_opts);\n  request = protocol.request(request_opts, function(resp) {\n\n    var headers = resp.headers;\n    debug('Got response', resp.statusCode, headers);\n    out.emit('response', resp);\n\n    set_timeout('read', config.read_timeout);\n\n    // if we got cookies, parse them unless we were instructed not to. make sure to include any\n    // cookies that might have been set on previous redirects.\n    if (config.parse_cookies && (headers['set-cookie'] || config.previous_resp_cookies)) {\n      resp.cookies = extend(config.previous_resp_cookies || {}, cookies.read(headers['set-cookie']));\n      debug('Got cookies', resp.cookies);\n    }\n\n    // if redirect code is found, determine if we should follow it according to the given options.\n    if (redirect_codes.indexOf(resp.statusCode) !== -1 && self.should_follow(headers.location, config, uri)) {\n      // clear timer before following redirects to prevent unexpected setTimeout consequence\n      clearTimeout(timer);\n\n      if (count <= config.follow_max) {\n        out.emit('redirect', headers.location);\n\n        // unless 'follow_keep_method' is true, rewrite the request to GET before continuing.\n        if (!config.follow_keep_method) {\n          method    = 'GET';\n          post_data = null;\n          delete config.headers['content-length']; // in case the original was a multipart POST request.\n        }\n\n        // if follow_set_cookies is true, insert cookies in the next request's headers.\n        // we set both the original request cookies plus any response cookies we might have received.\n        if (config.follow_set_cookies && host_and_ports_match(headers.location, uri)) {\n          var request_cookies = cookies.read(config.headers['cookie']);\n          config.previous_resp_cookies = resp.cookies;\n          if (Object.keys(request_cookies).length || Object.keys(resp.cookies || {}).length) {\n            config.headers['cookie'] = cookies.write(extend(request_cookies, resp.cookies));\n          }\n        } else if (config.headers['cookie']) {\n          debug('Clearing original request cookie', config.headers['cookie']);\n          delete config.headers['cookie'];\n        }\n\n        if (config.follow_set_referer)\n          config.headers['referer'] = encodeURI(uri); // the original, not the destination URL.\n\n        config.headers['host'] = null; // clear previous Host header to avoid conflicts.\n\n        var redirect_url = resolve_url(headers.location, uri);\n        debug('Redirecting to ' +  redirect_url.toString());\n        return self.send_request(++count, method, redirect_url.toString(), config, post_data, out, callback);\n      } else if (config.follow_max > 0) {\n        return done(new Error('Max redirects reached. Possible loop in: ' + headers.location));\n      }\n    }\n\n    // if auth is requested and credentials were not passed, resend request, provided we have user/pass.\n    if (resp.statusCode == 401 && headers['www-authenticate'] && config.credentials) {\n      if (!config.headers['authorization']) { // only if authentication hasn't been sent\n        var auth_header = auth.header(headers['www-authenticate'], config.credentials, request_opts);\n\n        if (auth_header) {\n          config.headers['authorization'] = auth_header;\n          return self.send_request(count, method, uri, config, post_data, out, callback);\n        }\n      }\n    }\n\n    // ok, so we got a valid (non-redirect & authorized) response. let's notify the stream guys.\n    out.emit('header', resp.statusCode, headers);\n    out.emit('headers', headers);\n\n    var pipeline      = [],\n        mime          = parse_content_type(headers['content-type']),\n        text_response = mime.type && (mime.type.indexOf('text/') != -1 || !!mime.type.match(/(\\/|\\+)(xml|json)$/));\n\n    // To start, if our body is compressed and we're able to inflate it, do it.\n    if (headers['content-encoding'] && decompressors[headers['content-encoding']]) {\n\n      var decompressor = decompressors[headers['content-encoding']]();\n\n      // make sure we catch errors triggered by the decompressor.\n      decompressor.on('error', had_error);\n      pipeline.push(decompressor);\n    }\n\n    // If parse is enabled and we have a parser for it, then go for it.\n    if (config.parser && parsers[mime.type]) {\n\n      // If a specific parser was requested, make sure we don't parse other types.\n      var parser_name = config.parser.toString().toLowerCase();\n      if (['xml', 'json'].indexOf(parser_name) == -1 || parsers[mime.type].name == parser_name) {\n\n        // OK, so either we're parsing all content types or the one requested matches.\n        out.parser = parsers[mime.type].name;\n        pipeline.push(parsers[mime.type].fn());\n\n        // Set objectMode on out stream to improve performance.\n        out._writableState.objectMode = true;\n        out._readableState.objectMode = true;\n      }\n\n    // If we're not parsing, and unless decoding was disabled, we'll try\n    // decoding non UTF-8 bodies to UTF-8, using the iconv-lite library.\n    } else if (text_response && config.decode_response && mime.charset) {\n      pipeline.push(decoder(mime.charset));\n    }\n\n    // And `out` is the stream we finally push the decoded/parsed output to.\n    pipeline.push(out);\n\n    // Now, release the kraken!\n    pump_streams([resp].concat(pipeline), function(err) {\n      if (err) debug(err)\n\n      // on node v8.x, if an error ocurrs on the receiving end,\n      // then we want to abort the request to avoid having dangling sockets\n      if (err && err.message == 'write after end') request.destroy();\n    });\n\n    // If the user has requested and output file, pipe the output stream to it.\n    // In stream mode, we will still get the response stream to play with.\n    if (config.output && resp.statusCode == 200) {\n\n      // for some reason, simply piping resp to the writable stream doesn't\n      // work all the time (stream gets cut in the middle with no warning).\n      // so we'll manually need to do the readable/write(chunk) trick.\n      var file = fs.createWriteStream(config.output);\n      file.on('error', had_error);\n\n      out.on('end', function() {\n        if (file.writable) file.end();\n      });\n\n      file.on('close', function() {\n        delete out.file;\n      })\n\n      out.on('readable', function() {\n        var chunk;\n        while ((chunk = this.read()) !== null) {\n          if (file.writable) file.write(chunk);\n\n          // if callback was requested, also push it to resp.body\n          if (resp.body) resp.body.push(chunk);\n        }\n      })\n\n      out.file = file;\n    }\n\n    // Only aggregate the full body if a callback was requested.\n    if (callback) {\n      resp.raw   = [];\n      resp.body  = [];\n      resp.bytes = 0;\n\n      // Gather and count the amount of (raw) bytes using a PassThrough stream.\n      var clean_pipe = new stream.PassThrough();\n\n      clean_pipe.on('readable', function() {\n        var chunk;\n        while ((chunk = this.read()) != null) {\n          resp.bytes += chunk.length;\n          resp.raw.push(chunk);\n        }\n      })\n\n      pump_streams([resp, clean_pipe], function(err) {\n        if (err) debug(err);\n      });\n\n      // Listen on the 'readable' event to aggregate the chunks, but only if\n      // file output wasn't requested. Otherwise we'd have two stream readers.\n      if (!config.output || resp.statusCode != 200) {\n        out.on('readable', function() {\n          var chunk;\n          while ((chunk = this.read()) !== null) {\n            // We're either pushing buffers or objects, never strings.\n            if (typeof chunk == 'string') chunk = Buffer.from(chunk);\n\n            // Push all chunks to resp.body. We'll bind them in resp.end().\n            resp.body.push(chunk);\n          }\n        })\n      }\n    }\n\n    // And set the .body property once all data is in.\n    out.on('end', function() {\n      if (resp.body) { // callback mode\n\n        // we want to be able to access to the raw data later, so keep a reference.\n        resp.raw = Buffer.concat(resp.raw);\n\n        // if parse was successful, we should have an array with one object\n        if (resp.body[0] !== undefined && !Buffer.isBuffer(resp.body[0])) {\n\n          // that's our body right there.\n          resp.body = resp.body[0];\n\n          // set the parser property on our response. we may want to check.\n          if (out.parser) resp.parser = out.parser;\n\n        } else { // we got one or several buffers. string or binary.\n          resp.body = Buffer.concat(resp.body);\n\n          // if we're here and parsed is true, it means we tried to but it didn't work.\n          // so given that we got a text response, let's stringify it.\n          if (text_response || out.parser) {\n            resp.body = resp.body.toString();\n          }\n        }\n      }\n\n      // if an output file is being written to, make sure the callback\n      // is triggered after all data has been written to it.\n      if (out.file) {\n        out.file.on('close', function() {\n          done(null, resp);\n        })\n      } else { // elvis has left the building.\n        done(null, resp);\n      }\n\n    });\n\n    // out.on('error', function(err) {\n    //   had_error(err);\n    //   if (err.code == 'ERR_STREAM_DESTROYED' || err.code == 'ERR_STREAM_PREMATURE_CLOSE') {\n    //     request.abort();\n    //   }\n    // })\n\n  }); // end request call\n\n  // unless open_timeout was disabled, set a timeout to abort the request.\n  set_timeout('open', config.open_timeout);\n\n  // handle errors on the request object. things might get bumpy.\n  request.on('error', had_error);\n\n  // make sure timer is cleared if request is aborted (issue #257)\n  request.once('abort', function() {\n    if (timer) clearTimeout(timer);\n  })\n\n  // handle socket 'end' event to ensure we don't get delayed EPIPE errors.\n  request.once('socket', function(socket) {\n    if (socket.connecting) {\n      socket.once('connect', function() {\n        set_timeout('response', config.response_timeout);\n      })\n    } else {\n      set_timeout('response', config.response_timeout);\n    }\n\n    // socket.once('close', function(e) {\n    //   console.log('socket closed!', e);\n    // })\n\n    if (!socket.on_socket_end) {\n      socket.on_socket_end = on_socket_end;\n      socket.once('end', function() { process.nextTick(on_socket_end.bind(socket)) });\n    }\n  })\n\n  if (post_data) {\n    if (is_stream(post_data)) {\n      pump_streams([post_data, request], function(err) {\n        if (err) debug(err);\n      });\n    } else {\n      request.write(post_data, config.encoding);\n      request.end();\n    }\n  } else {\n    request.end();\n  }\n\n  out.abort = function() { request.abort() }; // easier access\n  out.request = request;\n  return out;\n}\n\n//////////////////////////////////////////\n// exports\n\nif (typeof Promise !== 'undefined') {\n  module.exports = function() {\n    var verb, args = [].slice.call(arguments);\n\n    if (args[0].match(/\\.|\\//)) // first argument looks like a URL\n      verb = (args.length > 2) ? 'post' : 'get';\n    else\n      verb = args.shift();\n\n    if (verb.match(/get|head/i) && args.length == 2)\n      args.splice(1, 0, null); // assume no data if head/get with two args (url, options)\n\n    return new Promise(function(resolve, reject) {\n      module.exports.request(verb, args[0], args[1], args[2], function(err, resp) {\n        return err ? reject(err) : resolve(resp);\n      });\n    })\n  }\n}\n\nmodule.exports.version = version;\n\nmodule.exports.defaults = function(obj) {\n  for (var key in obj) {\n    var target_key = aliased.options[key] || key;\n\n    if (defaults.hasOwnProperty(target_key) && typeof obj[key] != 'undefined') {\n      if (target_key != 'parse_response' && target_key != 'proxy' && target_key != 'agent') {\n        // ensure type matches the original, except for proxy/parse_response that can be null/bool or string\n        var valid_type = defaults[target_key].constructor.name;\n\n        if (obj[key].constructor.name != valid_type)\n          throw new TypeError('Invalid type for ' + key + ', should be ' + valid_type);\n      }\n      defaults[target_key] = obj[key];\n    } else {\n      throw new Error('Invalid property for defaults:' + target_key);\n    }\n  }\n\n  return defaults;\n}\n\n'head get'.split(' ').forEach(function(method) {\n  module.exports[method] = function(uri, options, callback) {\n    return new Needle(method, uri, null, options, callback).start();\n  }\n})\n\n'post put patch delete'.split(' ').forEach(function(method) {\n  module.exports[method] = function(uri, data, options, callback) {\n    return new Needle(method, uri, data, options, callback).start();\n  }\n})\n\nmodule.exports.request = function(method, uri, data, opts, callback) {\n  return new Needle(method, uri, data, opts, callback).start();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}