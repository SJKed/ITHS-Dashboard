{"ast":null,"code":"//////////////////////////////////////////\n// Defines mappings between content-type\n// and the appropriate parsers.\n//////////////////////////////////////////\nvar Transform = require('stream').Transform;\n\nvar sax = require('sax');\n\nfunction parseXML(str, cb) {\n  var obj,\n      current,\n      parser = sax.parser(true, {\n    trim: true,\n    lowercase: true\n  });\n  parser.onerror = parser.onend = done;\n\n  function done(err) {\n    parser.onerror = parser.onend = function () {};\n\n    cb(err, obj);\n  }\n\n  function newElement(name, attributes) {\n    return {\n      name: name || '',\n      value: '',\n      attributes: attributes || {},\n      children: []\n    };\n  }\n\n  parser.oncdata = parser.ontext = function (t) {\n    if (current) current.value += t;\n  };\n\n  parser.onopentag = function (node) {\n    var element = newElement(node.name, node.attributes);\n\n    if (current) {\n      element.parent = current;\n      current.children.push(element);\n    } else {\n      // root object\n      obj = element;\n    }\n\n    current = element;\n  };\n\n  parser.onclosetag = function () {\n    if (typeof current.parent !== 'undefined') {\n      var just_closed = current;\n      current = current.parent;\n      delete just_closed.parent;\n    }\n  };\n\n  parser.write(str).close();\n}\n\nfunction parserFactory(name, fn) {\n  function parser() {\n    var chunks = [],\n        stream = new Transform({\n      objectMode: true\n    }); // Buffer all our data\n\n    stream._transform = function (chunk, encoding, done) {\n      chunks.push(chunk);\n      done();\n    }; // And call the parser when all is there.\n\n\n    stream._flush = function (done) {\n      var self = this,\n          data = Buffer.concat(chunks);\n\n      try {\n        fn(data, function (err, result) {\n          if (err) throw err;\n          self.push(result);\n        });\n      } catch (err) {\n        self.push(data); // just pass the original data\n      } finally {\n        done();\n      }\n    };\n\n    return stream;\n  }\n\n  return {\n    fn: parser,\n    name: name\n  };\n}\n\nvar parsers = {};\n\nfunction buildParser(name, types, fn) {\n  var parser = parserFactory(name, fn);\n  types.forEach(function (type) {\n    parsers[type] = parser;\n  });\n}\n\nbuildParser('json', ['application/json', 'text/javascript', 'application/vnd.api+json'], function (buffer, cb) {\n  var err, data;\n\n  try {\n    data = JSON.parse(buffer);\n  } catch (e) {\n    err = e;\n  }\n\n  cb(err, data);\n});\nbuildParser('xml', ['text/xml', 'application/xml', 'application/rdf+xml', 'application/rss+xml', 'application/atom+xml'], function (buffer, cb) {\n  parseXML(buffer.toString(), function (err, obj) {\n    cb(err, obj);\n  });\n});\nmodule.exports = parsers;\nmodule.exports.use = buildParser;","map":{"version":3,"names":["Transform","require","sax","parseXML","str","cb","obj","current","parser","trim","lowercase","onerror","onend","done","err","newElement","name","attributes","value","children","oncdata","ontext","t","onopentag","node","element","parent","push","onclosetag","just_closed","write","close","parserFactory","fn","chunks","stream","objectMode","_transform","chunk","encoding","_flush","self","data","Buffer","concat","result","parsers","buildParser","types","forEach","type","buffer","JSON","parse","e","toString","module","exports","use"],"sources":["/mnt/c/users/46721/documents/iths/ITHS-Dashboard/node_modules/needle/lib/parsers.js"],"sourcesContent":["//////////////////////////////////////////\n// Defines mappings between content-type\n// and the appropriate parsers.\n//////////////////////////////////////////\n\nvar Transform = require('stream').Transform;\nvar sax = require('sax');\n\nfunction parseXML(str, cb) {\n  var obj, current, parser = sax.parser(true, { trim: true, lowercase: true })\n  parser.onerror = parser.onend = done;\n\n  function done(err) {\n    parser.onerror = parser.onend = function() { }\n    cb(err, obj)\n  }\n\n  function newElement(name, attributes) {\n    return {\n      name: name || '',\n      value: '',\n      attributes: attributes || {},\n      children: []\n    }\n  }\n\n  parser.oncdata = parser.ontext = function(t) {\n    if (current) current.value += t\n  }\n\n  parser.onopentag = function(node) {\n    var element = newElement(node.name, node.attributes)\n    if (current) {\n      element.parent = current\n      current.children.push(element)\n    } else { // root object\n      obj = element\n    }\n\n    current = element\n  };\n\n  parser.onclosetag = function() {\n    if (typeof current.parent !== 'undefined') {\n      var just_closed = current\n      current = current.parent\n      delete just_closed.parent\n    }\n  }\n\n  parser.write(str).close()\n}\n\nfunction parserFactory(name, fn) {\n\n  function parser() {\n    var chunks = [],\n        stream = new Transform({ objectMode: true });\n\n    // Buffer all our data\n    stream._transform = function(chunk, encoding, done) {\n      chunks.push(chunk);\n      done();\n    }\n\n    // And call the parser when all is there.\n    stream._flush = function(done) {\n      var self = this,\n          data = Buffer.concat(chunks);\n\n      try {\n        fn(data, function(err, result) {\n          if (err) throw err;\n          self.push(result);\n        });\n      } catch (err) {\n        self.push(data); // just pass the original data\n      } finally {\n        done();\n      }\n    }\n\n    return stream;\n  }\n\n  return { fn: parser, name: name };\n}\n\nvar parsers = {}\n\nfunction buildParser(name, types, fn) {\n  var parser = parserFactory(name, fn);\n  types.forEach(function(type) {\n    parsers[type] = parser;\n  })\n}\n\nbuildParser('json', [\n  'application/json',\n  'text/javascript',\n  'application/vnd.api+json'\n], function(buffer, cb) {\n  var err, data;\n  try { data = JSON.parse(buffer); } catch (e) { err = e; }\n  cb(err, data);\n});\n\nbuildParser('xml', [\n  'text/xml',\n  'application/xml',\n  'application/rdf+xml',\n  'application/rss+xml',\n  'application/atom+xml'\n], function(buffer, cb) {\n  parseXML(buffer.toString(), function(err, obj) {\n    cb(err, obj)\n  })\n});\n\nmodule.exports = parsers;\nmodule.exports.use = buildParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}